name: ðŸ¤– Dictionary Auto-Sync

on:
  # Run every 2 minutes
  schedule:
    - cron: '*/2 * * * *'
  
  # Manual trigger
  workflow_dispatch:
  
  # Trigger on repository dispatch
  repository_dispatch:
    types: [dictionary_sync]
  
  # Also run when issues are created
  issues:
    types: [opened]

jobs:
  sync-dictionary:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup environment
        run: |
          echo "ðŸ”„ Setting up environment..."
          sudo apt-get update
          sudo apt-get install -y jq
          mkdir -p data
          mkdir -p backups
          mkdir -p sync-data
      
      - name: Load existing dictionary
        id: load_dict
        run: |
          echo "ðŸ“š Loading existing dictionary..."
          
          if [ -f "dictionary.json" ]; then
            echo "âœ… Found existing dictionary.json"
            # Create backup before any changes
            cp dictionary.json "dictionary_backup_$(date +%s).json"
          else
            echo "ðŸ“ Creating initial dictionary.json"
            echo '{"words": [], "metadata": {"created": "'$(date -Iseconds)'", "version": "1.0", "totalWords": 0}}' > dictionary.json
          fi
      
      - name: Process sync requests
        id: process_sync
        run: |
          echo "ðŸ”„ Processing sync requests..."
          
          # Load current dictionary words
          CURRENT_WORDS=$(jq -c '.words' dictionary.json 2>/dev/null || echo '[]')
          echo "$CURRENT_WORDS" > sync-data/current-words.json
          
          # Initialize merged words with current words
          MERGED_WORDS="$CURRENT_WORDS"
          
          # Check if triggered by issue
          if [ "${{ github.event_name }}" = "issues" ]; then
            echo "ðŸ“¥ Processing issue #${{ github.event.issue.number }}"
            
            # Try to extract JSON from issue body
            ISSUE_BODY="${{ github.event.issue.body }}"
            
            if echo "$ISSUE_BODY" | grep -q '```json'; then
              JSON_DATA=$(echo "$ISSUE_BODY" | sed -n '/```json/,/```/p' | sed '1d;$d')
              
              if [ -n "$JSON_DATA" ]; then
                echo "$JSON_DATA" > sync-data/issue-data.json
                ISSUE_WORDS=$(echo "$JSON_DATA" | jq -c '.words // []' 2>/dev/null || echo '[]')
                
                if [ "$ISSUE_WORDS" != "[]" ]; then
                  MERGED_WORDS=$(echo "$MERGED_WORDS" | jq ". + $ISSUE_WORDS")
                  echo "âœ… Added words from issue"
                fi
              fi
            fi
          fi
          
          # Check if triggered by repository dispatch
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "ðŸ“¥ Processing repository dispatch..."
            
            # Create payload file
            echo '${{ toJson(github.event.client_payload) }}' > sync-data/dispatch-data.json
            
            DISPATCH_WORDS=$(jq -c '.words // []' sync-data/dispatch-data.json 2>/dev/null || echo '[]')
            
            if [ "$DISPATCH_WORDS" != "[]" ]; then
              MERGED_WORDS=$(echo "$MERGED_WORDS" | jq ". + $DISPATCH_WORDS")
              echo "âœ… Added words from dispatch"
            fi
          fi
          
          # Save merged words
          echo "$MERGED_WORDS" > sync-data/merged-words.json
          
          MERGED_COUNT=$(echo "$MERGED_WORDS" | jq 'length')
          echo "ðŸ“Š Total words before deduplication: $MERGED_COUNT"
          echo "merged_count=$MERGED_COUNT" >> $GITHUB_OUTPUT
      
      - name: Deduplicate words
        id: deduplicate
        run: |
          echo "ðŸŽ¯ Deduplicating words..."
          
          MERGED_WORDS=$(cat sync-data/merged-words.json)
          
          if [ "$MERGED_WORDS" = "[]" ]; then
            echo "[]" > sync-data/deduplicated-words.json
            echo "deduplicated_count=0" >> $GITHUB_OUTPUT
            echo "âœ… No words to deduplicate"
            exit 0
          fi
          
          # Create a simple deduplication by word text (case-insensitive)
          # This is a simplified version - in production you'd want more sophisticated merging
          
          # Convert to array and process with jq
          DEDUPLICATED_WORDS=$(echo "$MERGED_WORDS" | jq '
            # Group by word (case-insensitive)
            group_by(.word | ascii_downcase) |
            # For each group, take the first (most recent by updatedAt if available)
            map(sort_by(.updatedAt // .createdAt // "1970-01-01") | reverse | .[0])
          ')
          
          echo "$DEDUPLICATED_WORDS" > sync-data/deduplicated-words.json
          
          DEDUPLICATED_COUNT=$(echo "$DEDUPLICATED_WORDS" | jq 'length')
          echo "ðŸ“Š Unique words after deduplication: $DEDUPLICATED_COUNT"
          echo "deduplicated_count=$DEDUPLICATED_COUNT" >> $GITHUB_OUTPUT
      
      - name: Update dictionary.json
        run: |
          echo "ðŸ“ Updating dictionary.json..."
          
          DEDUPLICATED_WORDS=$(cat sync-data/deduplicated-words.json)
          TIMESTAMP=$(date -Iseconds)
          WORD_COUNT=$(echo "$DEDUPLICATED_WORDS" | jq 'length')
          
          # Create the updated dictionary
          cat > dictionary.json << EOF
{
  "words": $DEDUPLICATED_WORDS,
  "metadata": {
    "lastSync": "$TIMESTAMP",
    "totalWords": $WORD_COUNT,
    "version": "2.0",
    "source": "GitHub Actions Auto-Sync",
    "syncId": "${{ github.run_id }}",
    "trigger": "${{ github.event_name }}"
  }
}
EOF
          
          echo "âœ… dictionary.json updated"
          echo "ðŸ“Š Total words: $WORD_COUNT"
      
      - name: Create individual word files
        run: |
          echo "ðŸ“ Creating individual word files..."
          
          # Clean and recreate data directory
          rm -rf data
          mkdir -p data
          
          # Count before creating
          echo "Creating individual word files..."
          
          # Create individual word files
          jq -c '.words[]' dictionary.json | while read -r word; do
            # Extract word name safely
            WORD_NAME=$(echo "$word" | jq -r '.word // "unknown"' | tr ' ' '_' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_]//g')
            
            # Skip if word name is empty or too long
            if [ -n "$WORD_NAME" ] && [ "${#WORD_NAME}" -lt 50 ]; then
              echo "$word" | jq '.' > "data/${WORD_NAME}.json"
            fi
          done
          
          FILE_COUNT=$(ls -1 data/*.json 2>/dev/null | wc -l || echo 0)
          echo "âœ… Created $FILE_COUNT individual word files"
      
      - name: Create JavaScript data file
        run: |
          echo "ðŸŒ Creating JavaScript data file..."
          
          DICT_DATA=$(cat dictionary.json)
          TIMESTAMP=$(date)
          WORD_COUNT=$(echo "$DICT_DATA" | jq '.words | length')
          
          cat > dictionary-data.js << EOF
// ===== DICTIONARY DATA =====
// Auto-generated by GitHub Actions
// Last sync: $TIMESTAMP
// Sync ID: ${{ github.run_id }}
// Total words: $WORD_COUNT

const dictionaryData = $DICT_DATA;

// Make available globally
if (typeof window !== 'undefined') {
  window.dictionaryData = dictionaryData;
  
  // Notify dictionary manager if it exists
  if (window.dictionary && typeof window.dictionary.onDataUpdate === 'function') {
    try {
      window.dictionary.onDataUpdate(dictionaryData);
    } catch (error) {
      console.log('âš ï¸ Could not auto-update dictionary:', error);
    }
  }
}

console.log('ðŸ“š Dictionary loaded:', dictionaryData.words.length, 'words');
console.log('ðŸ”„ Last sync:', dictionaryData.metadata.lastSync);
console.log('ðŸŽ¯ Source:', dictionaryData.metadata.source);
EOF
          
          echo "âœ… Created dictionary-data.js"
      
      - name: Create organized backup
        run: |
          echo "ðŸ’¾ Creating backup..."
          
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          BACKUP_DIR="backups/$(date +%Y/%m/%d)"
          BACKUP_FILE="${BACKUP_DIR}/dictionary_${TIMESTAMP}.json"
          
          # Create directory structure
          mkdir -p "$BACKUP_DIR"
          
          # Create backup
          cp dictionary.json "$BACKUP_FILE"
          
          # Also create a latest copy
          cp dictionary.json "backups/dictionary_latest.json"
          
          # Keep only last 50 backups total
          ls -1 backups/*/*/*.json 2>/dev/null | head -n -50 | xargs -r rm -f
          
          echo "âœ… Backup created: $BACKUP_FILE"
      
      - name: Commit and push changes
        id: commit
        run: |
          echo "ðŸš€ Committing changes..."
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add all files
          git add dictionary.json dictionary-data.js data/ backups/
          
          # Check if there are changes
          if git diff --staged --quiet; then
            echo "âœ… No changes to commit"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            # Create commit
            TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
            WORD_COUNT=$(jq '.words | length' dictionary.json)
            
            git commit -m "ðŸ¤– Auto-sync: ${TIMESTAMP} (${WORD_COUNT} words)"
            
            # Push changes
            git push
            
            echo "âœ… Changes committed and pushed"
            echo "ðŸ“Š Word count: ${WORD_COUNT}"
            echo "â° Sync time: ${TIMESTAMP}"
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Close issue if processed
        if: github.event_name == 'issues' && steps.commit.outputs.changes_made == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const dictionary = JSON.parse(fs.readFileSync('dictionary.json', 'utf8'));
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## âœ… Dictionary Sync Completed!\n\n` +
                    `**Total Words:** ${dictionary.words.length}\n` +
                    `**Last Sync:** ${dictionary.metadata.lastSync}\n` +
                    `**Sync ID:** ${context.runId}\n\n` +
                    `âœ… Your changes have been successfully synced to all devices.\n\n` +
                    `ðŸ”— **View Live Data:** https://raw.githubusercontent.com/${context.repo.owner}/${context.repo.repo}/main/dictionary.json\n` +
                    `ðŸ”— **Web App:** https://${context.repo.owner}.github.io/${context.repo.repo}/\n\n` +
                    `*This issue was automatically closed by the sync workflow.*`
            });
            
            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              state: 'closed'
            });
      
      - name: Create sync report
        run: |
          echo "ðŸ“Š Creating sync report..."
          
          WORD_COUNT=$(jq '.words | length' dictionary.json)
          TIMESTAMP=$(date)
          
          cat >> sync-log.txt << EOF
================================
Sync Report: ${{ github.run_id }}
Time: $TIMESTAMP
Event: ${{ github.event_name }}
Words: $WORD_COUNT
Status: âœ… Success
================================

EOF
          
          # Add to git
          git add sync-log.txt 2>/dev/null || true
          git commit -m "ðŸ“ Update sync log" 2>/dev/null || true
          git push 2>/dev/null || true
      
      - name: Final status
        run: |
          echo "ðŸŽ‰ Sync completed successfully!"
          echo "================================="
          echo "ðŸ“Š Final word count: $(jq '.words | length' dictionary.json)"
          echo "ðŸ•’ Completion time: $(date)"
          echo "ðŸ”„ Next sync in 2 minutes"
          echo "ðŸ”— Live data: https://raw.githubusercontent.com/${{ github.repository }}/main/dictionary.json"
          echo "ðŸ”— Web app: https://${{ github.repository_owner }}.github.io/$(echo ${{ github.repository }} | cut -d'/' -f2)/"
          echo "================================="